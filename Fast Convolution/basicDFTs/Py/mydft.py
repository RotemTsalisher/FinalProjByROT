# -*- coding: utf-8 -*-
"""myDFT.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1F91FtsRKfxP-e0xUiNhV7c_QQn0cIeYB
"""

import numpy as np
from matplotlib import pyplot as plt

aprox_cos = np.array([
    1.0, 0.923879533, 0.707106781, 0.382683432, 0, -0.382683432, -0.707106781, -0.923879533,
    -1.0, -0.923879533, -0.707106781, -0.382683432, 0, 0.382683432, 0.707106781, 0.923879533

])
aprox_sin = np.array([
    0.0, 0.382683432, 0.707106781, 0.923879533, 1.0, 0.923879533, 0.707106781, 0.382683432, 0,
    -0.382683432, -0.707106781, -0.923879533, -1.0, -0.923879533, -0.707106781, -0.382683432

])

class Complex:
    def __init__(self, re, imag):
        self.r = re
        self.i = imag

    def complexMult(self,num):
        return Complex((self.r*num.r - self.i*num.i), (self.r*num.i + self.i*num.r))

    def complexAdd(self,num):
      return Complex(self.r + num.r, self.i + num.i);

    def printSig(self):
      if self.i < 0:
        print(self.r, " - j", -self.i)
        return
      print(self.r, " + j", self.i)

    def swapRealImag(self):
      tmp = self.r
      self.r = self.i
      self.i = tmp
      return

    def __mul__(self, other):
      if isinstance(other, float):
          self.r *= other
          self.i *= other
          return self
      elif isinstance(other, Complex):
          return Complex(self.r * other.r - self.i * other.i, self.r * other.i + self.i * other.r)
      else:
          raise TypeError("Unsupported operand type for *: Complex and {}".format(type(other)))

    def __rmul__(self, other):
      if isinstance(other, float):
          self.r *= other
          self.i *= other
          return self
      else:
          raise TypeError("Unsupported operand type for *: {} and Complex".format(type(other)))

def myFFT(sig,twiddleArr,N=0):
  M = len(sig);
  if N == 0 or N > M:
    N = M
  X = [];
  for k in range(N):
    tmp = Complex(0,0)
    for n in range(N):
      tmp = tmp.complexAdd(sig[n].complexMult(twiddleArr[(n*k)%N]));
    X.append(tmp)

  return np.array(X);

def forward_dft(x,N):
  w0 = int(np.floor(16/N))
  twiddleArr = np.array([Complex(aprox_cos[w0*k],-aprox_sin[w0*k]) for k in range(N)]);
  X = myFFT(x,twiddleArr,N);
  return X

def printCmplxArr(arr):
  for ele in arr:
    ele.printSig()

  return;

def idft_using_dft(x,N):
  for ele in x:
    ele.swapRealImag()

  x = (1/N)*forward_dft(x,N)

  for ele in x:
    ele.swapRealImag()

  return x

def main():
  x = np.array([Complex(1,0),Complex(1,0),Complex(1,0),Complex(0,0)]);
  N = 4;
  print("Original sig: ");
  printCmplxArr(x);
  print("Forward FFT:");
  X = forward_dft(x,N);
  printCmplxArr(X);

  x_ = idft_using_dft(X,N);
  print("After iDFT:");
  printCmplxArr(x_);
  return

main()